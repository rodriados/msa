#!/usr/bin/env bash
# Multiple Sequence Alignment cluster hosts finder script.
# @author Rodrigo Siqueira <rodriados@gmail.com>
# @copyright 2018 Rodrigo Siqueira

# The aim of this script is to generate a file containing a list of hosts currently
# available in the cluster. The script will only look for computers with CUDA capable
# devices. After listing the hosts, the file generated by this script will be used to
# configure the application execution.

# Declaring escape sequences and style constants.
readonly s_bold="\033[1m"
readonly s_reset="\033[0m"

# Command to check whether a host is compute capable or not.
readonly gpucmd="lspci | grep 'VGA' | grep 'NVIDIA'"

# Checks whether a host has a compute capable device. This is done by simply
# connecting to the host and executing a command to check whether it is compute
# capable or not.
sshrun()
{
    # Access remote host in batch mode without tty allocation and runs the
    # command to find out the number of connected GPUs.
    ssh -o ConnectTimeout=5 -o BatchMode=yes -o StrictHostKeyChecking=no -T $1 << EOF
        ${gpucmd} | wc -l
        exit
EOF
}

# Automatically generates a hostfile for MPI execution. This script only
# looks for GPU capable machines in local networks. If the user desires to
# to use external nodes, the file shall be created manually.
findhosts()
{
    # Printing process information.
    printf "${s_bold}[info]${s_reset} generating hosts file\n"

    # Discovers the name of file to be created. If no valid file name is given,
    # the name is defaulted to "hostfile".
    if [[ ! -z "$1" && (! -e "$1" || -f "$1") ]]; then
        local target_file="$1"
    else
        local target_file="hostfile"
    fi

    # Removes the target file, if it exists and shifts the command line arguments.
    # This is needed so we can guarantee we will append to an empty file.
    if [[ -f "$target_file" ]]; then
        rm $target_file
    fi

    # Counts how many slots we can give the local host.
    local gpu_count=$(eval "$gpucmd" | wc -l)

    # Checks whether this machine is compute capable and check how many devices it
    # currently has.
    echo "localhost slots=$((gpu_count + 1)) max-slots=$((gpu_count + 1))" >> $target_file

    # Gets the list of hosts known by the current machine.
    local hosts_list=$(getent hosts | cut -d' ' -f1 | tr "\n" " ")
    local hosts_count=$(wc -w <<< "$hosts_list")

    # Discovers the internal network IP of this machine.
    local ip_local=$(hostname -I)

    # Reports the execution progress
    local loop_count=0

    # Iterating through the list of hosts to try to find hosts capable of running
    # the software. As MPI uses ssh internally to implement communication between
    # nodes, we use ssh as well to look for hosts.    
    for host in ${hosts_list[@]}; do
        # Inform the current progress.        
        watchdog $loop_count $hosts_count "connecting to $host"

        # Checking for local hosts only. We do not want to use external nodes when
        # executing. The user shall create the hosts file manually otherwise.
        if [[ "$ip_local" != *"$host"* && ("$host" == 192.168.* || "$host" == 10.*) ]]; then
            # Accessing remote host via ssh and retrieving the number of connected
            # compute-capable devices.
            gpu_count=$(sshrun $host 2> /dev/null)

            # If the number of devices found is greater than zero, than we can use
            # this host to execute our code.
            if [[ "$gpu_count" -gt 0 ]]; then
                echo "$host slots=$gpu_count max-slots=$gpu_count" >> $target_file
            fi
        fi

        # Update the loop count.
        loop_count=$((loop_count + 1))
    done

    # Inform the progress is over.
    watchdog $loop_count $hosts_count "hosts file successfully created"
}

# Creates a new named pipe and returns its name. The pipe allows to stablish
# communication to and from an external process.
createpipe()
{
    # Creates a named pipe. The name of the pipe will simply be that of a
    # temporary file, which not forceably exists.
    local pipe=$(mktemp -u)
    mkfifo $pipe

    # Return the name of pipe created.
    echo $pipe
}

# Prints watchdog information so the user can know how it will take them to complete
# the file generation.
watchdog()
{
    local args=($@)
    printf "[watchdog] hostfinder 1 1 %d %d %s\n" $1 $2 "${args[*]:2}"
}

# Lists all available command line options and shows information about them,
# letting the user know what is the use of this script.
showhelp()
{
    echo "Usage: hostfinder [options] file"
    echo "Options:"
    echo "  -h, --help                  Prints this information."
    echo "  -f, --file      <file>      The file to be generated."
    echo "  -w, --watchdog              Display watchdog messages."
}

# Presents an error when an unrecognized command line option is detected. This
# allows the user to know that one of the options they requested do not exist.
invalid_arg()
{
    printf "[error] unrecognized command line option '%s'\n" $1
}

# Initializing command line variables and flags
file=
watchdog=false
positional=()

# Parses the command line options and sets all respective variables. Any positional
# value unlinked to any option sent will also be captured.
while [ $# -gt 0 ]; do
    case $1 in
        -h | --help     )   showhelp;           exit 0  ;;
        -f | --file     )   file="$2";          shift 2 ;;
        -w | --watchdog )   watchdog=true;      shift   ;;
        -* | --*        )   invalid_arg $1;     exit 0  ;;
        *               )   positional+=("$1"); shift   ;;
    esac
done

# If no file option has been sent, we can get it from positional values. If neither
# options are available, the file name will be posteriorly default-defined.
if [ -z "$file" ]; then
    file="${positional[0]}"
    positional=("${positional[@]:1}")
fi

# Starts the script and tries to create the requested host file. If watchdog mode is not
# requested, the watchdog script will be invoked to show a progressbar.
if [ "$watchdog" = false ]; then
    #Creates the pipe to communicate with watchdog process.
    pipe=$(createpipe)
    trap 'rm -f $pipe' EXIT

    # Initializes the scan for hosts in network in backgound and redirects its
    # output to a watchdog process. After the operation is over, the pipe will be
    # automatically deleted.
    findhosts $file ${positional[@]} >$pipe &
    src/watchdog.sh $! <$pipe
    wait $! 2>/dev/null
else
    # If the script has been invoked in watchdog mode, than it shall show watchdog
    # messages while scanning for hosts.
    findhosts $file ${positional[@]}
fi
